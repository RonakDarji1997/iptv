package com.ronika.iptvnative

import android.os.Bundle
import android.view.KeyEvent
import android.view.View
import android.widget.FrameLayout
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.ProgressBar
import android.widget.TextView
import android.widget.ScrollView
import androidx.activity.ComponentActivity
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import androidx.media3.ui.PlayerView
import androidx.recyclerview.widget.GridLayoutManager
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import coil.load
import com.ronika.iptvnative.adapters.CategoryAdapter
import com.ronika.iptvnative.adapters.ChannelAdapter
import com.ronika.iptvnative.adapters.ChannelRowAdapter
import com.ronika.iptvnative.api.ApiClient
import com.ronika.iptvnative.api.ChannelsRequest
import com.ronika.iptvnative.api.GenreRequest
import com.ronika.iptvnative.api.MoviesRequest
import com.ronika.iptvnative.models.Genre
import com.ronika.iptvnative.models.Channel
import com.ronika.iptvnative.models.Movie
import com.ronika.iptvnative.models.Series
import kotlinx.coroutines.launch

class MainActivity : ComponentActivity() {
    
    // UI Components - Top Navigation
    private lateinit var tvTab: android.widget.ImageView
    private lateinit var moviesTab: android.widget.ImageView
    private lateinit var showsTab: android.widget.ImageView
    private lateinit var sidebarContainer: LinearLayout
    
    // UI Components - Sidebar
    private lateinit var categorySidebar: LinearLayout
    private lateinit var categoryHeaderText: TextView
    private lateinit var categoriesRecycler: RecyclerView
    
    // UI Components - Content Area
    private lateinit var playerPreviewContainer: LinearLayout
    private lateinit var playerContainer: FrameLayout
    private lateinit var playerView: PlayerView
    private lateinit var contentHeader: LinearLayout
    private lateinit var contentListContainer: FrameLayout
    private lateinit var contentTitle: TextView
    private lateinit var contentSubtitle: TextView
    private lateinit var contentRecycler: RecyclerView
    private lateinit var emptyStateMessage: TextView
    private lateinit var loadingIndicator: ProgressBar
    
    // UI Components - Preview Panel
    private lateinit var previewPanel: ScrollView
    private lateinit var previewPoster: ImageView
    private lateinit var previewChannelName: TextView
    private lateinit var previewTime: TextView
    private lateinit var previewProgramInfo: TextView
    private lateinit var previewMetaRow: LinearLayout
    private lateinit var previewYear: TextView
    private lateinit var previewRating: TextView
    private lateinit var previewDuration: TextView
    private lateinit var previewGenres: TextView
    private lateinit var previewDescription: TextView
    private lateinit var previewCastContainer: LinearLayout
    private lateinit var previewActors: TextView
    private lateinit var previewDirectorContainer: LinearLayout
    private lateinit var previewDirector: TextView
    private lateinit var previewHint: TextView
    
    // Movie Details Header (above grid when browsing)
    private lateinit var movieDetailsHeaderGrid: LinearLayout
    private lateinit var detailPosterGrid: ImageView
    private lateinit var detailPosterTextGrid: TextView
    private lateinit var detailTitleGrid: TextView
    private lateinit var detailYearGrid: TextView
    private lateinit var detailDurationGrid: TextView
    private lateinit var detailGenreGrid: TextView
    private lateinit var detailCastGrid: TextView
    private lateinit var detailDirectorGrid: TextView
    private lateinit var detailDescriptionGrid: TextView
    
    // Movie Details Overlay (fullscreen - shows for 3 seconds)
    private lateinit var movieDetailsHeader: LinearLayout
    private lateinit var detailPoster: ImageView
    private lateinit var detailPosterText: TextView
    private lateinit var detailTitle: TextView
    private lateinit var detailYear: TextView
    private lateinit var detailDuration: TextView
    private lateinit var detailGenre: TextView
    private lateinit var detailCast: TextView
    private lateinit var detailDirector: TextView
    private lateinit var detailDescription: TextView
    
    // Custom Player Controls
    private var progressContainer: LinearLayout? = null
    private var liveBadgeContainer: LinearLayout? = null
    private var rewindButton: View? = null
    private var forwardButton: View? = null
    private var fullscreenInfo: LinearLayout? = null
    private var fullscreenChannelName: TextView? = null
    private var fullscreenProgramInfo: TextView? = null
    
    // Players - Separate for Live TV and VOD
    private var livePlayer: ExoPlayer? = null
    private var vodPlayer: ExoPlayer? = null
    private var currentPlayingChannel: Channel? = null
    private var currentPlayingCategoryId: String? = null  // Track which category has the playing channel
    private var currentPlayingCategoryIndex: Int = -1  // Track the index of the category that's playing
    private var isFullscreen = false
    private var currentPlayingIndex = 0
    
    // UI Components - Debug
    private lateinit var debugSelectedTab: TextView
    private lateinit var debugHoverTab: TextView
    private lateinit var debugSidebarState: TextView
    
    // Adapters
    private lateinit var categoryAdapter: CategoryAdapter
    private lateinit var channelAdapter: ChannelAdapter
    private lateinit var channelRowAdapter: ChannelRowAdapter
    
    // State
    private var selectedTab = "TV"
    private var hoverTab = "TV"
    private var sidebarExpanded = true
    private var categories: List<Genre> = emptyList()
    private var selectedCategoryIndex = -1 // -1 means no category selected
    private var hasCategorySelected = false
    private var currentPage = 1
    private var isLoadingMore = false
    private var hasMorePages = true
    private val allChannels = mutableListOf<Channel>()
    private val allMovies = mutableListOf<Movie>() // Store full movie objects with metadata
    private val allSeries = mutableListOf<Series>() // Store full series objects with metadata
    private var totalItemsCount = 0
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // Set API credentials with actual values
        ApiClient.setCredentials(
            mac = "00:1A:79:17:F4:F5",
            portal = "http://tv.stream4k.cc/stalker_portal/"
        )
        
        // Initialize views
        initializeViews()
        
        // Setup adapters
        setupAdapters()
        
        // Setup listeners
        setupTabListeners()
        setupFocusListeners()
        
        // Load initial data
        loadCategories()
        
        // Set initial focus
        tvTab.requestFocus()
        updateDebugDisplay()
    }
    
    private fun initializeViews() {
        // Top Navigation
        tvTab = findViewById(R.id.tab_tv)
        moviesTab = findViewById(R.id.tab_movies)
        showsTab = findViewById(R.id.tab_shows)
        sidebarContainer = findViewById(R.id.sidebar_container)
        
        // Sidebar
        categorySidebar = findViewById(R.id.category_sidebar)
        categoryHeaderText = findViewById(R.id.category_header_text)
        categoriesRecycler = findViewById(R.id.categories_recycler)
        
        // Content Area
        playerPreviewContainer = findViewById(R.id.player_preview_container)
        playerContainer = findViewById(R.id.player_container)
        playerView = findViewById(R.id.player_view)
        contentHeader = findViewById(R.id.content_header)
        contentListContainer = findViewById(R.id.content_list_container)
        contentTitle = findViewById(R.id.content_title)
        contentSubtitle = findViewById(R.id.content_subtitle)
        contentRecycler = findViewById(R.id.content_recycler)
        emptyStateMessage = findViewById(R.id.empty_state_message)
        loadingIndicator = findViewById(R.id.loading_indicator)
        
        // Preview Panel
        previewPanel = findViewById(R.id.preview_panel)
        previewPoster = findViewById(R.id.preview_poster)
        previewChannelName = findViewById(R.id.preview_channel_name)
        previewTime = findViewById(R.id.preview_time)
        previewProgramInfo = findViewById(R.id.preview_program_info)
        previewMetaRow = findViewById(R.id.preview_meta_row)
        previewYear = findViewById(R.id.preview_year)
        previewRating = findViewById(R.id.preview_rating)
        previewDuration = findViewById(R.id.preview_duration)
        previewGenres = findViewById(R.id.preview_genres)
        previewDescription = findViewById(R.id.preview_description)
        previewCastContainer = findViewById(R.id.preview_cast_container)
        previewActors = findViewById(R.id.preview_actors)
        previewDirectorContainer = findViewById(R.id.preview_director_container)
        previewDirector = findViewById(R.id.preview_director)
        previewHint = findViewById(R.id.preview_hint)
        
        // Movie Details Header (Grid)
        movieDetailsHeaderGrid = findViewById(R.id.movie_details_header_grid)
        detailPosterGrid = findViewById(R.id.detail_poster_grid)
        detailPosterTextGrid = findViewById(R.id.detail_poster_text_grid)
        detailTitleGrid = findViewById(R.id.detail_title_grid)
        detailYearGrid = findViewById(R.id.detail_year_grid)
        detailDurationGrid = findViewById(R.id.detail_duration_grid)
        detailGenreGrid = findViewById(R.id.detail_genre_grid)
        detailCastGrid = findViewById(R.id.detail_cast_grid)
        detailDirectorGrid = findViewById(R.id.detail_director_grid)
        detailDescriptionGrid = findViewById(R.id.detail_description_grid)
        
        // Movie Details Overlay (Fullscreen)
        movieDetailsHeader = findViewById(R.id.movie_details_header)
        detailPoster = findViewById(R.id.detail_poster)
        detailPosterText = findViewById(R.id.detail_poster_text)
        detailTitle = findViewById(R.id.detail_title)
        detailYear = findViewById(R.id.detail_year)
        detailDuration = findViewById(R.id.detail_duration)
        detailGenre = findViewById(R.id.detail_genre)
        detailCast = findViewById(R.id.detail_cast)
        detailDirector = findViewById(R.id.detail_director)
        detailDescription = findViewById(R.id.detail_description)
        
        // Debug
        debugSelectedTab = findViewById(R.id.debug_selected_tab)
        debugHoverTab = findViewById(R.id.debug_hover_tab)
        debugSidebarState = findViewById(R.id.debug_sidebar_state)
        
        // Initialize players
        setupPlayers()
        
        // Setup preview container focus behavior
        playerPreviewContainer.setOnFocusChangeListener { _, hasFocus ->
            if (hasFocus) {
                // White background when focused
                playerPreviewContainer.setBackgroundColor(android.graphics.Color.WHITE)
                // Show fullscreen hint
                if (selectedTab == "TV" && currentPlayingChannel != null) {
                    previewProgramInfo.text = "Press OK for fullscreen"
                }
            } else {
                // Transparent when not focused
                playerPreviewContainer.setBackgroundColor(android.graphics.Color.TRANSPARENT)
                // Restore normal preview info
                if (selectedTab == "TV" && currentPlayingChannel != null) {
                    previewProgramInfo.text = "Live TV"
                }
            }
        }
    }
    
    private fun setupPlayers() {
        // Setup Live TV Player
        livePlayer = ExoPlayer.Builder(this)
            .setSeekBackIncrementMs(10000)
            .setSeekForwardIncrementMs(10000)
            .build()
            .apply {
                // Add listener to track player state
                addListener(object : Player.Listener {
                    override fun onPlaybackStateChanged(playbackState: Int) {
                        when (playbackState) {
                            Player.STATE_IDLE -> android.util.Log.d("MainActivity", "Live Player: IDLE")
                            Player.STATE_BUFFERING -> android.util.Log.d("MainActivity", "Live Player: BUFFERING")
                            Player.STATE_READY -> android.util.Log.d("MainActivity", "Live Player: READY")
                            Player.STATE_ENDED -> android.util.Log.d("MainActivity", "Live Player: ENDED")
                        }
                    }
                    
                    override fun onPlayerError(error: androidx.media3.common.PlaybackException) {
                        android.util.Log.e("MainActivity", "Live Player error: ${error.message}", error)
                        android.util.Log.e("MainActivity", "Error type: ${error.errorCode}")
                        
                        // Try to recover from error
                        lifecycleScope.launch {
                            kotlinx.coroutines.delay(1000)
                            currentPlayingChannel?.let { channel ->
                                android.util.Log.d("MainActivity", "Attempting to recover playback")
                                playChannel(channel)
                            }
                        }
                    }
                    
                    override fun onIsPlayingChanged(isPlaying: Boolean) {
                        android.util.Log.d("MainActivity", "Live Player isPlaying: $isPlaying")
                    }
                })
            }
            
        // Setup VOD Player
        vodPlayer = ExoPlayer.Builder(this)
            .setSeekBackIncrementMs(10000)
            .setSeekForwardIncrementMs(10000)
            .build()
            .apply {
                addListener(object : Player.Listener {
                    override fun onPlaybackStateChanged(playbackState: Int) {
                        when (playbackState) {
                            Player.STATE_IDLE -> android.util.Log.d("MainActivity", "VOD Player: IDLE")
                            Player.STATE_BUFFERING -> android.util.Log.d("MainActivity", "VOD Player: BUFFERING")
                            Player.STATE_READY -> android.util.Log.d("MainActivity", "VOD Player: READY")
                            Player.STATE_ENDED -> android.util.Log.d("MainActivity", "VOD Player: ENDED")
                        }
                    }
                    
                    override fun onPlayerError(error: androidx.media3.common.PlaybackException) {
                        android.util.Log.e("MainActivity", "VOD Player error: ${error.message}", error)
                        android.util.Log.e("MainActivity", "Error type: ${error.errorCode}")
                    }
                    
                    override fun onIsPlayingChanged(isPlaying: Boolean) {
                        android.util.Log.d("MainActivity", "VOD Player isPlaying: $isPlaying")
                    }
                })
            }
        
        // Start with live player for TV tab
        playerView.player = livePlayer
        playerView.useController = true
        playerView.controllerAutoShow = false
        playerView.controllerHideOnTouch = false
        
        // Setup custom player controls after a short delay to ensure they're inflated
        playerView.post {
            setupCustomPlayerControls()
        }
    }
    
    private fun setupCustomPlayerControls() {
        // Find custom control views
        progressContainer = playerView.findViewById(R.id.progress_container)
        liveBadgeContainer = playerView.findViewById(R.id.live_badge_container)
        rewindButton = playerView.findViewById(R.id.exo_rew)
        forwardButton = playerView.findViewById(R.id.exo_ffwd)
        fullscreenInfo = playerView.findViewById(R.id.fullscreen_info)
        fullscreenChannelName = playerView.findViewById(R.id.fullscreen_channel_name)
        fullscreenProgramInfo = playerView.findViewById(R.id.fullscreen_program_info)
        
        // Update control visibility based on current channel
        updatePlayerControlsForContentType()
    }
    
    private fun updatePlayerControlsForContentType() {
        val isLive = currentPlayingChannel?.isLive == true
        
        // Show/hide progress bar vs LIVE badge
        progressContainer?.visibility = if (isLive) View.GONE else View.VISIBLE
        liveBadgeContainer?.visibility = if (isLive) View.VISIBLE else View.GONE
        
        // Show/hide seek buttons for live content
        rewindButton?.visibility = if (isLive) View.GONE else View.VISIBLE
        forwardButton?.visibility = if (isLive) View.GONE else View.VISIBLE
        
        // Update fullscreen info
        if (isFullscreen && isLive) {
            fullscreenInfo?.visibility = View.VISIBLE
            fullscreenChannelName?.text = currentPlayingChannel?.name ?: ""
            fullscreenProgramInfo?.text = "Live TV"
        } else {
            fullscreenInfo?.visibility = View.GONE
        }
    }
    
    private fun setupAdapters() {
        // Category adapter
        categoryAdapter = CategoryAdapter { genre ->
            onCategorySelected(genre)
        }
        categoriesRecycler.apply {
            layoutManager = LinearLayoutManager(this@MainActivity)
            adapter = categoryAdapter
        }
        
        // Channel row adapter for Live TV
        channelRowAdapter = ChannelRowAdapter(
            onChannelSelected = { channel ->
                onChannelSelected(channel)
            },
            onChannelFocused = { channel ->
                // Show preview when hovering over a channel (without playing)
                if (selectedTab == "TV" && !isFullscreen) {
                    showPreviewForChannel(channel)
                }
            }
        )
        
        // Channel grid adapter for Movies/Series
        channelAdapter = ChannelAdapter(
            onChannelSelected = { channel ->
                onChannelSelected(channel)
            },
            onChannelFocused = { channel ->
                // Show preview for movies/series when hovering
                if (selectedTab != "TV") {
                    showMoviePreview(channel)
                }
            }
        )
        
        // Will switch adapter based on selected tab
        setupContentAdapter()
    }
    
    private fun setupContentAdapter() {
        contentRecycler.apply {
            // Optimize view caching for better performance
            setItemViewCacheSize(10) // Cache 10 off-screen items
            setHasFixedSize(false) // Grid columns can change
            
            if (selectedTab == "TV") {
                // Use row layout for Live TV
                layoutManager = LinearLayoutManager(this@MainActivity)
                adapter = channelRowAdapter
                
                // Intercept key events to prevent LEFT from going to preview
                setOnKeyListener { _, keyCode, event ->
                    if (keyCode == KeyEvent.KEYCODE_DPAD_LEFT && event.action == KeyEvent.ACTION_DOWN) {
                        // Let the main onKeyDown handler deal with it
                        return@setOnKeyListener false
                    }
                    false
                }
                
                // Add scroll listener for lazy loading
                clearOnScrollListeners()
                addOnScrollListener(object : RecyclerView.OnScrollListener() {
                    override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                        super.onScrolled(recyclerView, dx, dy)
                        val layoutManager = recyclerView.layoutManager as LinearLayoutManager
                        val visibleItemCount = layoutManager.childCount
                        val totalItemCount = layoutManager.itemCount
                        val firstVisibleItemPosition = layoutManager.findFirstVisibleItemPosition()
                        
                        if (!isLoadingMore && hasMorePages && dy > 0) {
                            if ((visibleItemCount + firstVisibleItemPosition) >= totalItemCount - 10) {
                                loadMoreContent()
                            }
                        }
                    }
                })
            } else {
                // Use grid layout for Movies/Series
                val displayMetrics = resources.displayMetrics
                val screenWidthPx = displayMetrics.widthPixels
                val density = displayMetrics.density
                
                // Calculate available width in pixels (check current visibility)
                val sidebarWidthPx = if (categorySidebar.visibility == View.VISIBLE) {
                    (360 * density).toInt() // 80dp main + 280dp categories
                } else {
                    (80 * density).toInt() // Only main sidebar
                }
                val paddingPx = (40 * density).toInt() // RecyclerView padding
                val availableWidthPx = screenWidthPx - sidebarWidthPx - paddingPx
                
                // Item dimensions (160dp card + 16dp margins = 176dp per item)
                val cardWidthDp = 160f
                val cardMarginDp = 8f * 2 // left + right margin (8dp each side)
                val itemTotalWidthDp = cardWidthDp + cardMarginDp
                val itemTotalWidthPx = (itemTotalWidthDp * density).toInt()
                
                // Calculate columns that fit in available width
                val columns = (availableWidthPx / itemTotalWidthPx).coerceAtLeast(3)
                
                android.util.Log.d("MainActivity", "Grid calculation: screenWidth=$screenWidthPx, available=$availableWidthPx, itemWidth=$itemTotalWidthPx, columns=$columns, categoriesVisible=${categorySidebar.visibility == View.VISIBLE}")
                
                layoutManager = GridLayoutManager(this@MainActivity, columns)
                adapter = channelAdapter
                
                // Disable item animations for smoother scrolling
                itemAnimator = null
                
                // Add scroll listener for lazy loading
                clearOnScrollListeners()
                addOnScrollListener(object : RecyclerView.OnScrollListener() {
                    override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                        super.onScrolled(recyclerView, dx, dy)
                        val layoutManager = recyclerView.layoutManager as GridLayoutManager
                        val visibleItemCount = layoutManager.childCount
                        val totalItemCount = layoutManager.itemCount
                        val firstVisibleItemPosition = layoutManager.findFirstVisibleItemPosition()
                        
                        if (!isLoadingMore && hasMorePages && dy > 0) {
                            if ((visibleItemCount + firstVisibleItemPosition) >= totalItemCount - 10) {
                                loadMoreContent()
                            }
                        }
                    }
                })
            }
        }
    }
    
    private fun setupTabListeners() {
        tvTab.setOnClickListener {
            switchTab("TV")
        }
        
        moviesTab.setOnClickListener {
            switchTab("MOVIES")
        }
        
        showsTab.setOnClickListener {
            switchTab("SHOWS")
        }
    }
    
    private fun setupFocusListeners() {
        tvTab.setOnFocusChangeListener { view, hasFocus ->
            if (hasFocus) {
                hoverTab = "TV"
                view.setBackgroundResource(R.drawable.tab_selected)
                // Black icon on white background
                tvTab.setColorFilter(android.graphics.Color.BLACK)
                updateDebugDisplay()
            } else {
                applySelectedStyle(view, "TV")
            }
        }
        
        moviesTab.setOnFocusChangeListener { view, hasFocus ->
            if (hasFocus) {
                hoverTab = "MOVIES"
                view.setBackgroundResource(R.drawable.tab_selected)
                // Black icon on white background
                moviesTab.setColorFilter(android.graphics.Color.BLACK)
                updateDebugDisplay()
            } else {
                applySelectedStyle(view, "MOVIES")
            }
        }
        
        showsTab.setOnFocusChangeListener { view, hasFocus ->
            if (hasFocus) {
                hoverTab = "SHOWS"
                view.setBackgroundResource(R.drawable.tab_selected)
                // Black icon on white background
                showsTab.setColorFilter(android.graphics.Color.BLACK)
                updateDebugDisplay()
            } else {
                applySelectedStyle(view, "SHOWS")
            }
        }
    }
    
    private fun applySelectedStyle(view: View, tab: String) {
        val imageView = view as android.widget.ImageView
        if (tab == selectedTab) {
            view.setBackgroundResource(R.drawable.tab_selected)
            // Black icon on white background for selected tab
            imageView.setColorFilter(android.graphics.Color.BLACK)
        } else {
            view.setBackgroundResource(R.drawable.nav_item_normal)
            // White icon on dark background for normal tabs
            imageView.setColorFilter(android.graphics.Color.WHITE)
        }
    }
    
    private fun switchTab(tab: String) {
        // Store previous tab to check if we're switching or returning
        val previousTab = selectedTab
        
        // Stop live player if switching away from TV tab
        if (selectedTab == "TV" && tab != "TV") {
            android.util.Log.d("MainActivity", "Switching from TV to $tab - stopping live player")
            livePlayer?.apply {
                stop()
                clearMediaItems()
            }
            currentPlayingChannel = null
        }
        
        // Stop VOD player if switching away from movies/shows
        if ((selectedTab == "MOVIES" || selectedTab == "SHOWS") && tab == "TV") {
            android.util.Log.d("MainActivity", "Switching to TV - stopping VOD player")
            vodPlayer?.apply {
                stop()
                clearMediaItems()
            }
        }
        
        selectedTab = tab
        
        // Only reset category selection if switching between DIFFERENT tabs
        // This preserves the selected category when returning to the same tab
        if (previousTab != tab) {
            selectedCategoryIndex = -1
            hasCategorySelected = false
            // Clear playing state when switching tabs
            currentPlayingChannel = null
            currentPlayingCategoryId = null
            currentPlayingCategoryIndex = -1
            currentPlayingIndex = 0
            // Clear adapters play positions
            channelRowAdapter.setPlayingPosition(-1)
            categoryAdapter.setActivePosition(-1)
        }
        
        // For Movies/Shows: Hide main sidebar after selection, show categories
        if (tab == "MOVIES" || tab == "SHOWS") {
            sidebarContainer.visibility = View.GONE
            categorySidebar.visibility = View.VISIBLE
        } else {
            // For TV: Start with fullscreen view (both sidebars hidden)
            // This will be set correctly after loadCategories() auto-selects first category
            sidebarContainer.visibility = View.GONE
            categorySidebar.visibility = View.GONE
        }
        
        updateTabStyles()
        setupContentAdapter() // Switch between row/grid adapter
        loadCategories()
        updateDebugDisplay()
    }
    
    private fun updateTabStyles() {
        // Apply styles to all tabs based on selected state
        applySelectedStyle(tvTab, "TV")
        applySelectedStyle(moviesTab, "MOVIES")
        applySelectedStyle(showsTab, "SHOWS")
    }
    
    private fun updateDebugDisplay() {
        debugSelectedTab.text = "Selected: $selectedTab"
        debugHoverTab.text = "Hover: $hoverTab"
        debugSidebarState.text = "Sidebar: ${if (sidebarExpanded) "Expanded" else "Collapsed"}"
    }
    
    private fun toggleSidebar() {
        sidebarExpanded = !sidebarExpanded
        categorySidebar.visibility = if (sidebarExpanded) View.VISIBLE else View.GONE
        updateDebugDisplay()
    }
    
    private fun loadCategories() {
        android.util.Log.d("MainActivity", "loadCategories called for tab: $selectedTab")
        lifecycleScope.launch {
            try {
                android.util.Log.d("MainActivity", "Starting to load categories")
                loadingIndicator.visibility = View.VISIBLE
                
                when (selectedTab) {
                    "TV" -> {
                        android.util.Log.d("MainActivity", "Loading TV genres")
                        // Show player/preview container and "All Playlists" header for TV
                        playerPreviewContainer.visibility = View.VISIBLE
                        categoryHeaderText.visibility = View.VISIBLE
                        movieDetailsHeaderGrid.visibility = View.GONE
                        movieDetailsHeader.visibility = View.GONE
                        
                        val response = ApiClient.apiService.getGenres(
                            GenreRequest(ApiClient.macAddress, ApiClient.portalUrl)
                        )
                        // Filter out non-numeric category IDs
                        categories = response.genres.filter { genre ->
                            genre.id.toIntOrNull() != null
                        }
                        categoryAdapter.setCategories(categories)
                        
                        // Auto-select first category for TV and load channels
                        if (categories.isNotEmpty()) {
                            selectedCategoryIndex = 0
                            hasCategorySelected = true
                            categoryAdapter.setActivePosition(0)
                            // Start with fullscreen view - both sidebars hidden
                            sidebarContainer.visibility = View.GONE
                            categorySidebar.visibility = View.GONE
                            loadChannels(categories[0].id)
                            // Focus on first channel
                            contentRecycler.requestFocus()
                            contentRecycler.post {
                                contentRecycler.getChildAt(0)?.requestFocus()
                            }
                        }
                    }
                    "MOVIES" -> {
                        // Hide player/preview container and "All Playlists" header for movies
                        playerPreviewContainer.visibility = View.GONE
                        categoryHeaderText.visibility = View.GONE
                        movieDetailsHeaderGrid.visibility = View.GONE
                        movieDetailsHeader.visibility = View.GONE
                        
                        val response = ApiClient.apiService.getMovieCategories(
                            ApiClient.getCredentials()
                        )
                        // Filter out non-numeric category IDs
                        categories = response.categories
                            .filter { it.id.toIntOrNull() != null }
                            .map { Genre(it.id, it.title, it.name) }
                        categoryAdapter.setCategories(categories)
                        
                        // DON'T auto-select - show empty state and focus on first category
                        if (categories.isNotEmpty()) {
                            contentRecycler.visibility = View.GONE
                            emptyStateMessage.visibility = View.VISIBLE
                            emptyStateMessage.text = "Select a category to see movies"
                            // Focus on first category with white bar but don't select
                            categoriesRecycler.requestFocus()
                            categoriesRecycler.post {
                                categoriesRecycler.getChildAt(0)?.requestFocus()
                            }
                        }
                    }
                    "SHOWS" -> {
                        // Hide player/preview container and "All Playlists" header for series
                        playerPreviewContainer.visibility = View.GONE
                        categoryHeaderText.visibility = View.GONE
                        movieDetailsHeaderGrid.visibility = View.GONE
                        movieDetailsHeader.visibility = View.GONE
                        val response = ApiClient.apiService.getSeriesCategories(
                            ApiClient.getCredentials()
                        )
                        // Filter out non-numeric category IDs
                        categories = response.categories
                            .filter { it.id.toIntOrNull() != null }
                            .map { Genre(it.id, it.title, it.name) }
                        categoryAdapter.setCategories(categories)
                        
                        // DON'T auto-select - show empty state and focus on first category
                        if (categories.isNotEmpty()) {
                            contentRecycler.visibility = View.GONE
                            emptyStateMessage.visibility = View.VISIBLE
                            emptyStateMessage.text = "Select a category to see series"
                            // Focus on first category with white bar but don't select
                            categoriesRecycler.requestFocus()
                            categoriesRecycler.post {
                                categoriesRecycler.getChildAt(0)?.requestFocus()
                            }
                        }
                    }
                }
                
                android.util.Log.d("MainActivity", "Categories loaded successfully")
                loadingIndicator.visibility = View.GONE
            } catch (e: Exception) {
                android.util.Log.e("MainActivity", "Error loading categories: ${e.message}", e)
                e.printStackTrace()
                loadingIndicator.visibility = View.GONE
            }
        }
    }
    
    private fun onCategorySelected(genre: Genre) {
        selectedCategoryIndex = categories.indexOf(genre)
        hasCategorySelected = true
        contentTitle.text = genre.getDisplayName()
        
        // Don't set active position here - it will be set when channel actually plays
        // categoryAdapter.setActivePosition(selectedCategoryIndex)
        
        // Hide empty state, show content
        emptyStateMessage.visibility = View.GONE
        contentRecycler.visibility = View.VISIBLE
        
        // Progressive disclosure: Hide categories sidebar AND main sidebar after selection
        // This applies to TV, Movies, and Shows
        categorySidebar.visibility = View.GONE
        sidebarContainer.visibility = View.GONE
        
        // Recalculate grid layout with new available width (for Movies/Shows)
        if (selectedTab == "MOVIES" || selectedTab == "SHOWS") {
            setupContentAdapter()
        }
        
        // Reset pagination
        currentPage = 1
        hasMorePages = true
        allChannels.clear()
        allMovies.clear()
        allSeries.clear()
        
        when (selectedTab) {
            "TV" -> loadChannels(genre.id)
            "MOVIES" -> loadMovies(genre.id)
            "SHOWS" -> loadSeries(genre.id)
        }
    }
    
    private fun loadChannels(genreId: String) {
        lifecycleScope.launch {
            try {
                loadingIndicator.visibility = View.VISIBLE
                allChannels.clear()
                currentPage = 1
                hasMorePages = true
                
                // Load first 5 pages
                for (page in 1..5) {
                    val response = ApiClient.apiService.getChannels(
                        ChannelsRequest(
                            mac = ApiClient.macAddress,
                            url = ApiClient.portalUrl,
                            genre = genreId,
                            page = page
                        )
                    )
                    
                    // Store total from first response
                    if (page == 1) {
                        totalItemsCount = response.channels.total
                        // Update header with total count
                        categoryHeaderText.text = "All Playlists ($totalItemsCount)"
                    }
                    
                    val channels = response.channels.data.map { channel ->
                        channel.copy(logo = buildChannelLogoUrl(channel.logo), isLive = true)
                    }
                    if (channels.isEmpty()) {
                        hasMorePages = false
                        break
                    }
                    allChannels.addAll(channels)
                }
                
                currentPage = 6
                channelRowAdapter.setChannels(allChannels)
                contentSubtitle.text = "$totalItemsCount channels"
                
                // Check if this category has the currently playing channel
                val isPlayingCategory = currentPlayingCategoryId == genreId
                
                // Set category active icon if this is the playing category
                if (isPlayingCategory && currentPlayingCategoryIndex >= 0) {
                    categoryAdapter.setActivePosition(currentPlayingCategoryIndex)
                } else {
                    // Clear active position if this is not the playing category
                    categoryAdapter.setActivePosition(-1)
                }
                
                // Don't auto-play if content is already playing
                if (allChannels.isNotEmpty() && currentPlayingChannel == null) {
                    channelRowAdapter.setSelectedPosition(0)
                    channelRowAdapter.setPlayingPosition(0)
                    currentPlayingCategoryId = genreId
                    currentPlayingCategoryIndex = selectedCategoryIndex
                    categoryAdapter.setActivePosition(currentPlayingCategoryIndex)
                    playChannel(allChannels[0])
                    contentRecycler.post {
                        contentRecycler.getChildAt(0)?.requestFocus()
                    }
                } else if (isPlayingCategory && currentPlayingIndex >= 0 && currentPlayingIndex < allChannels.size) {
                    // This category has the playing channel - show play indicator
                    channelRowAdapter.setSelectedPosition(0)
                    channelRowAdapter.setPlayingPosition(currentPlayingIndex)
                    // Focus on first channel, not preview
                    contentRecycler.post {
                        contentRecycler.getChildAt(0)?.requestFocus()
                    }
                } else {
                    // Different category - clear play indicator
                    channelRowAdapter.setSelectedPosition(0)
                    channelRowAdapter.setPlayingPosition(-1)
                    // Focus on first channel, not preview
                    contentRecycler.post {
                        contentRecycler.getChildAt(0)?.requestFocus()
                    }
                }
                
                loadingIndicator.visibility = View.GONE
            } catch (e: Exception) {
                android.util.Log.e("MainActivity", "Error loading channels", e)
                loadingIndicator.visibility = View.GONE
            }
        }
    }
    
    private fun loadMovies(categoryId: String) {
        lifecycleScope.launch {
            try {
                loadingIndicator.visibility = View.VISIBLE
                allChannels.clear()
                currentPage = 1
                hasMorePages = true
                
                // Load first 5 pages
                for (page in 1..5) {
                    val response = ApiClient.apiService.getMovies(
                        MoviesRequest(
                            mac = ApiClient.macAddress,
                            url = ApiClient.portalUrl,
                            category = categoryId,
                            page = page,
                            type = "vod"
                        )
                    )
                    
                    // Store total from first response
                    if (page == 1) {
                        totalItemsCount = response.items.total
                    }
                    
                    val movies = response.items.data
                    if (movies.isEmpty()) {
                        hasMorePages = false
                        break
                    }
                    
                    // Store full movie objects for rich metadata access
                    allMovies.addAll(movies)
                    
                    val movieChannels = movies.map {
                        Channel(it.id, it.name, null, buildImageUrl(it.getImageUrl()), it.cmd, categoryId)
                    }
                    allChannels.addAll(movieChannels)
                }
                
                currentPage = 6
                channelAdapter.setChannels(allChannels)
                contentSubtitle.text = "$totalItemsCount movies"
                
                // Select first movie but keep categories visible
                if (allChannels.isNotEmpty()) {
                    channelAdapter.setSelectedPosition(0)
                }
                
                loadingIndicator.visibility = View.GONE
            } catch (e: Exception) {
                android.util.Log.e("MainActivity", "Error loading movies", e)
                loadingIndicator.visibility = View.GONE
            }
        }
    }
    
    private fun loadSeries(categoryId: String) {
        lifecycleScope.launch {
            try {
                loadingIndicator.visibility = View.VISIBLE
                allChannels.clear()
                currentPage = 1
                hasMorePages = true
                
                // Load first 5 pages
                for (page in 1..5) {
                    val response = ApiClient.apiService.getSeries(
                        MoviesRequest(
                            mac = ApiClient.macAddress,
                            url = ApiClient.portalUrl,
                            category = categoryId,
                            page = page,
                            type = "vod"
                        )
                    )
                    
                    // Store total from first response
                    if (page == 1) {
                        totalItemsCount = response.items.total
                    }
                    
                    val series = response.items.data
                    if (series.isEmpty()) {
                        hasMorePages = false
                        break
                    }
                    
                    val seriesChannels = series.map {
                        Channel(it.id, it.name, null, buildImageUrl(it.getImageUrl()), it.cmd, categoryId)
                    }
                    allChannels.addAll(seriesChannels)
                }
                
                currentPage = 6
                channelAdapter.setChannels(allChannels)
                contentSubtitle.text = "$totalItemsCount series"
                
                // Select first item but keep categories visible
                if (allChannels.isNotEmpty()) {
                    channelAdapter.setSelectedPosition(0)
                }
                
                loadingIndicator.visibility = View.GONE
            } catch (e: Exception) {
                android.util.Log.e("MainActivity", "Error loading series", e)
                loadingIndicator.visibility = View.GONE
            }
        }
    }
    
    private fun loadMoreContent() {
        if (isLoadingMore || !hasMorePages || categories.isEmpty()) return
        
        isLoadingMore = true
        val selectedGenre = categories[selectedCategoryIndex]
        
        lifecycleScope.launch {
            try {
                when (selectedTab) {
                    "TV" -> {
                        val response = ApiClient.apiService.getChannels(
                            ChannelsRequest(
                                mac = ApiClient.macAddress,
                                url = ApiClient.portalUrl,
                                genre = selectedGenre.id,
                                page = currentPage
                            )
                        )
                        val channels = response.channels.data.map { channel ->
                            channel.copy(logo = buildChannelLogoUrl(channel.logo), isLive = true)
                        }
                        if (channels.isEmpty()) {
                            hasMorePages = false
                        } else {
                            allChannels.addAll(channels)
                            channelRowAdapter.setChannels(allChannels)
                            currentPage++
                        }
                    }
                    "MOVIES" -> {
                        val response = ApiClient.apiService.getMovies(
                            MoviesRequest(
                                mac = ApiClient.macAddress,
                                url = ApiClient.portalUrl,
                                category = selectedGenre.id,
                                page = currentPage,
                                type = "vod"
                            )
                        )
                        val movies = response.items.data
                        if (movies.isEmpty()) {
                            hasMorePages = false
                        } else {
                            allMovies.addAll(movies) // Store full movie objects
                            val movieChannels = movies.map {
                                Channel(it.id, it.name, null, buildImageUrl(it.getImageUrl()), it.cmd, selectedGenre.id)
                            }
                            allChannels.addAll(movieChannels)
                            channelAdapter.setChannels(allChannels)
                            currentPage++
                        }
                    }
                    "SHOWS" -> {
                        val response = ApiClient.apiService.getSeries(
                            MoviesRequest(
                                mac = ApiClient.macAddress,
                                url = ApiClient.portalUrl,
                                category = selectedGenre.id,
                                page = currentPage,
                                type = "vod"
                            )
                        )
                        val seriesData = response.items.data
                        if (seriesData.isEmpty()) {
                            hasMorePages = false
                        } else {
                            // Convert Movie objects to Series objects (API returns same structure)
                            val series = seriesData.map { movie ->
                                Series(
                                    id = movie.id,
                                    name = movie.name,
                                    year = movie.year,
                                    poster = movie.poster,
                                    screenshot = movie.screenshot,
                                    screenshotUri = movie.screenshotUri,
                                    cover = movie.cover,
                                    coverBig = movie.coverBig,
                                    ratingImdb = movie.ratingImdb,
                                    categoryId = movie.categoryId,
                                    description = movie.description,
                                    actors = movie.actors,
                                    director = movie.director,
                                    country = movie.country,
                                    genresStr = movie.genresStr,
                                    originalName = movie.originalName,
                                    totalEpisodes = null
                                )
                            }
                            allSeries.addAll(series)
                            val seriesChannels = seriesData.map {
                                Channel(it.id, it.name, null, buildImageUrl(it.getImageUrl()), it.cmd, selectedGenre.id)
                            }
                            allChannels.addAll(seriesChannels)
                            channelAdapter.setChannels(allChannels)
                            currentPage++
                        }
                    }
                }
                isLoadingMore = false
            } catch (e: Exception) {
                android.util.Log.e("MainActivity", "Error loading more content", e)
                isLoadingMore = false
            }
        }
    }
    
    private fun buildImageUrl(imagePath: String?): String? {
        if (imagePath.isNullOrEmpty()) return null
        
        // If already a full URL, return as is
        if (imagePath.startsWith("http")) {
            return imagePath
        }
        
        // Build full URL from portal
        val portalUrl = ApiClient.portalUrl
        val domainUrl = portalUrl.replace("/stalker_portal/?$".toRegex(), "")
        
        return if (imagePath.startsWith("/")) {
            "$domainUrl$imagePath"
        } else {
            imagePath
        }
    }
    
    private fun buildChannelLogoUrl(logo: String?): String? {
        if (logo.isNullOrEmpty()) return null
        
        // If already a full URL, return as is
        if (logo.startsWith("http")) {
            return logo
        }
        
        // Build full URL for channel logos
        val portalUrl = ApiClient.portalUrl
        val domainUrl = portalUrl.replace("/stalker_portal/?$".toRegex(), "")
        
        return if (logo.startsWith("/")) {
            "$domainUrl$logo"
        } else {
            "$domainUrl/stalker_portal/misc/logos/320/$logo"
        }
    }

    private fun onChannelSelected(channel: Channel) {
        // For TV channels, play the channel when user clicks on it
        if (selectedTab == "TV") {
            val channelIndex = allChannels.indexOf(channel)
            
            // If clicking on already playing channel (or from preview), toggle fullscreen
            if (currentPlayingChannel == channel) {
                toggleFullscreen()
                return
            }
            
            // Otherwise play the new channel
            currentPlayingIndex = channelIndex
            currentPlayingCategoryId = categories[selectedCategoryIndex].id
            currentPlayingCategoryIndex = selectedCategoryIndex
            playChannel(channel)
            
            // Update playing indicator in adapter
            if (channelIndex != -1) {
                channelRowAdapter.setSelectedPosition(channelIndex)
                channelRowAdapter.setPlayingPosition(channelIndex)
                categoryAdapter.setActivePosition(currentPlayingCategoryIndex)
            }
            
            // Show preview panel for the playing channel
            showPreviewForChannel(channel)
        } else {
            // For movies/series, show full-size image in player area
            showMovieFullscreen(channel)
        }
    }
    
    private fun showMoviePreview(channel: Channel) {
        // Show movie/show details in header above grid (not fullscreen overlay)
        movieDetailsHeaderGrid.visibility = View.VISIBLE
        
        // Find the full movie or series object by ID
        val movie = if (selectedTab == "MOVIES") allMovies.find { it.id == channel.id } else null
        val series = if (selectedTab == "SHOWS") allSeries.find { it.id == channel.id } else null
        
        // Title
        detailTitleGrid.text = channel.name
        
        // Load poster, or show title if no image available
        val imageUrl = movie?.getImageUrl() ?: series?.getImageUrl()
        val finalImageUrl = buildImageUrl(imageUrl)
        if (finalImageUrl != null) {
            detailPosterGrid.visibility = View.VISIBLE
            detailPosterTextGrid.visibility = View.GONE
            detailPosterGrid.load(finalImageUrl) {
                crossfade(200)
                placeholder(android.R.drawable.ic_menu_gallery)
                error(android.R.drawable.ic_menu_gallery)
                listener(
                    onError = { _, _ ->
                        // If image fails to load, show title instead
                        detailPosterGrid.visibility = View.GONE
                        detailPosterTextGrid.visibility = View.VISIBLE
                        detailPosterTextGrid.text = channel.name
                    }
                )
            }
        } else {
            // Show title as fallback when no poster is available
            detailPosterGrid.visibility = View.GONE
            detailPosterTextGrid.visibility = View.VISIBLE
            detailPosterTextGrid.text = channel.name
        }
        
        // Year
        val year = movie?.year ?: series?.year
        detailYearGrid.text = year ?: ""
        
        // Duration
        val duration = movie?.duration
        if (!duration.isNullOrEmpty()) {
            val totalMinutes = duration.toIntOrNull() ?: 0
            val hours = totalMinutes / 60
            val mins = totalMinutes % 60
            detailDurationGrid.text = if (hours > 0) "${hours}h ${mins}m" else "${mins}m"
        } else {
            // For series, could show episode count
            val episodes = series?.totalEpisodes
            detailDurationGrid.text = if (!episodes.isNullOrEmpty()) "$episodes Episodes" else ""
        }
        
        // Genre (combine country and genres)
        val genresStr = movie?.genresStr ?: series?.genresStr
        val country = movie?.country ?: series?.country
        val genreText = listOfNotNull(country, genresStr).joinToString(" | ")
        detailGenreGrid.text = genreText.ifEmpty { if (selectedTab == "MOVIES") "MOVIES" else "SERIES" }
        
        // Cast
        val actors = movie?.actors ?: series?.actors
        detailCastGrid.text = if (!actors.isNullOrEmpty()) "Cast:    $actors" else ""
        detailCastGrid.visibility = if (!actors.isNullOrEmpty()) View.VISIBLE else View.GONE
        
        // Director
        val director = movie?.director ?: series?.director
        detailDirectorGrid.text = if (!director.isNullOrEmpty()) "Director: $director" else ""
        detailDirectorGrid.visibility = if (!director.isNullOrEmpty()) View.VISIBLE else View.GONE
        
        // Description
        val description = movie?.description ?: series?.description
        detailDescriptionGrid.text = description ?: ""
        detailDescriptionGrid.visibility = if (!description.isNullOrEmpty()) View.VISIBLE else View.GONE
    }
    
    private fun showMovieFullscreen(channel: Channel) {
        // Hide other UI elements
        sidebarContainer.visibility = View.GONE
        categorySidebar.visibility = View.GONE
        contentHeader.visibility = View.GONE
        contentListContainer.visibility = View.GONE
        previewPanel.visibility = View.GONE
        movieDetailsHeaderGrid.visibility = View.GONE
        
        // Make player/preview container take full screen
        playerPreviewContainer.visibility = View.VISIBLE
        val containerParams = playerPreviewContainer.layoutParams as LinearLayout.LayoutParams
        containerParams.weight = 1.0f
        playerPreviewContainer.layoutParams = containerParams
        
        // Show player in full screen
        playerContainer.visibility = View.VISIBLE
        val params = playerContainer.layoutParams as LinearLayout.LayoutParams
        params.weight = 1.0f
        playerContainer.layoutParams = params
        
        // Ensure PlayerView is visible
        playerView.visibility = View.VISIBLE
        
        // Set fullscreen flag
        isFullscreen = true
        
        android.util.Log.d("MainActivity", "Showing movie fullscreen: ${channel.name}")
        
        // Show movie details overlay for 3 seconds then fade out
        showMovieInfoOverlay(channel)
        
        // Play the movie
        playChannel(channel)
    }
    
    private fun showMovieInfoOverlay(channel: Channel) {
        // Populate movie details
        val movie = if (selectedTab == "MOVIES") allMovies.find { it.id == channel.id } else null
        val series = if (selectedTab == "SHOWS") allSeries.find { it.id == channel.id } else null
        
        // Show the header with full opacity
        movieDetailsHeader.visibility = View.VISIBLE
        movieDetailsHeader.alpha = 1f
        
        // Update all the details
        detailTitle.text = channel.name
        
        // Load poster
        val imageUrl = movie?.getImageUrl() ?: series?.getImageUrl()
        val finalImageUrl = buildImageUrl(imageUrl)
        if (finalImageUrl != null) {
            detailPoster.visibility = View.VISIBLE
            detailPosterText.visibility = View.GONE
            detailPoster.load(finalImageUrl) {
                crossfade(200)
                placeholder(android.R.drawable.ic_menu_gallery)
                error(android.R.drawable.ic_menu_gallery)
                listener(
                    onError = { _, _ ->
                        detailPoster.visibility = View.GONE
                        detailPosterText.visibility = View.VISIBLE
                        detailPosterText.text = channel.name
                    }
                )
            }
        } else {
            detailPoster.visibility = View.GONE
            detailPosterText.visibility = View.VISIBLE
            detailPosterText.text = channel.name
        }
        
        // Year
        val year = movie?.year ?: series?.year
        detailYear.text = year ?: ""
        
        // Duration
        val duration = movie?.duration
        if (!duration.isNullOrEmpty()) {
            val totalMinutes = duration.toIntOrNull() ?: 0
            val hours = totalMinutes / 60
            val mins = totalMinutes % 60
            detailDuration.text = if (hours > 0) "${hours}h ${mins}m" else "${mins}m"
        } else {
            val episodes = series?.totalEpisodes
            detailDuration.text = if (!episodes.isNullOrEmpty()) "$episodes Episodes" else ""
        }
        
        // Genre
        val genresStr = movie?.genresStr ?: series?.genresStr
        val country = movie?.country ?: series?.country
        val genreText = listOfNotNull(country, genresStr).joinToString(" | ")
        detailGenre.text = genreText.ifEmpty { if (selectedTab == "MOVIES") "MOVIES" else "SERIES" }
        
        // Cast
        val actors = movie?.actors ?: series?.actors
        detailCast.text = if (!actors.isNullOrEmpty()) "Cast:    $actors" else ""
        detailCast.visibility = if (!actors.isNullOrEmpty()) View.VISIBLE else View.GONE
        
        // Director
        val director = movie?.director ?: series?.director
        detailDirector.text = if (!director.isNullOrEmpty()) "Director: $director" else ""
        detailDirector.visibility = if (!director.isNullOrEmpty()) View.VISIBLE else View.GONE
        
        // Description
        val description = movie?.description ?: series?.description
        detailDescription.text = description ?: ""
        detailDescription.visibility = if (!description.isNullOrEmpty()) View.VISIBLE else View.GONE
        
        // Auto-hide after 3 seconds with fade animation
        movieDetailsHeader.postDelayed({
            movieDetailsHeader.animate()
                .alpha(0f)
                .setDuration(500)
                .withEndAction {
                    movieDetailsHeader.visibility = View.GONE
                }
                .start()
        }, 3000)
    }
    
    private fun exitMovieFullscreen() {
        // Stop VOD playback
        android.util.Log.d("MainActivity", "Exiting movie fullscreen - stopping VOD player")
        vodPlayer?.apply {
            stop()
            clearMediaItems()
        }
        
        // Restore normal UI (but keep categories hidden for fullscreen movies)
        sidebarContainer.visibility = View.GONE // Keep main sidebar hidden
        categorySidebar.visibility = View.GONE // Keep categories hidden
        contentHeader.visibility = View.VISIBLE
        contentListContainer.visibility = View.VISIBLE
        
        // Restore container height for movies/series (hide player)
        playerPreviewContainer.visibility = View.GONE
        val containerParams = playerPreviewContainer.layoutParams as LinearLayout.LayoutParams
        containerParams.weight = 0.55f
        playerPreviewContainer.layoutParams = containerParams
        
        isFullscreen = false
        
        // Recalculate grid for fullscreen layout (no sidebars)
        if (selectedTab == "MOVIES" || selectedTab == "SHOWS") {
            setupContentAdapter()
        }
        
        // Return focus to selected movie
        contentRecycler.post {
            val selectedPos = channelAdapter.getSelectedPosition()
            val layoutManager = contentRecycler.layoutManager as? androidx.recyclerview.widget.GridLayoutManager
            layoutManager?.let {
                val viewAtPosition = it.findViewByPosition(selectedPos)
                viewAtPosition?.requestFocus()
            }
        }
        
        android.util.Log.d("MainActivity", "Exited movie fullscreen")
    }
    
    private fun toggleFullscreen() {
        isFullscreen = !isFullscreen
        
        if (isFullscreen) {
            // Hide UI elements for fullscreen
            sidebarContainer.visibility = View.GONE
            categorySidebar.visibility = View.GONE
            contentHeader.visibility = View.GONE
            contentListContainer.visibility = View.GONE
            previewPanel.visibility = View.GONE
            
            // Make player take full screen (100% width of player container)
            val params = playerContainer.layoutParams as LinearLayout.LayoutParams
            params.weight = 1.0f
            playerContainer.layoutParams = params
            
            // Make player/preview container take full height
            val containerParams = playerPreviewContainer.layoutParams as LinearLayout.LayoutParams
            containerParams.weight = 1.0f
            playerPreviewContainer.layoutParams = containerParams
            
            // Update player controls for fullscreen
            updatePlayerControlsForContentType()
            
            android.util.Log.d("MainActivity", "Entered fullscreen mode")
        } else {
            // Restore normal UI - but keep sidebars hidden for TV tab
            if (selectedTab != "TV") {
                sidebarContainer.visibility = View.VISIBLE
                categorySidebar.visibility = View.VISIBLE
            }
            contentHeader.visibility = View.VISIBLE
            contentListContainer.visibility = View.VISIBLE
            
            // Show preview panel for TV
            if (selectedTab == "TV") {
                previewPanel.visibility = View.VISIBLE
            }
            
            // Restore player size (70% width)
            val params = playerContainer.layoutParams as LinearLayout.LayoutParams
            params.weight = 0.7f
            playerContainer.layoutParams = params
            
            // Restore container height
            val containerParams = playerPreviewContainer.layoutParams as LinearLayout.LayoutParams
            containerParams.weight = 0.55f
            playerPreviewContainer.layoutParams = containerParams
            
            // Update player controls for normal view
            updatePlayerControlsForContentType()
            
            android.util.Log.d("MainActivity", "Exited fullscreen mode")
        }
    }
    
    private fun playNextChannel() {
        if (allChannels.isEmpty()) return
        
        currentPlayingIndex = (currentPlayingIndex + 1) % allChannels.size
        val channel = allChannels[currentPlayingIndex]
        
        playChannel(channel)
        channelRowAdapter.setPlayingPosition(currentPlayingIndex)
        channelRowAdapter.setSelectedPosition(currentPlayingIndex)
        
        // Update preview panel
        showPreviewForChannel(channel)
        
        // Scroll to show the current channel
        contentRecycler.smoothScrollToPosition(currentPlayingIndex)
        
        android.util.Log.d("MainActivity", "Playing next channel: ${channel.name}")
    }
    
    private fun playPreviousChannel() {
        if (allChannels.isEmpty()) return
        
        currentPlayingIndex = if (currentPlayingIndex - 1 < 0) allChannels.size - 1 else currentPlayingIndex - 1
        val channel = allChannels[currentPlayingIndex]
        
        playChannel(channel)
        channelRowAdapter.setPlayingPosition(currentPlayingIndex)
        channelRowAdapter.setSelectedPosition(currentPlayingIndex)
        
        // Update preview panel
        showPreviewForChannel(channel)
        
        // Scroll to show the current channel
        contentRecycler.smoothScrollToPosition(currentPlayingIndex)
        
        android.util.Log.d("MainActivity", "Playing previous channel: ${channel.name}")
    }
    
    private fun showPreviewForChannel(channel: Channel) {
        if (selectedTab == "TV" && !isFullscreen) {
            previewPanel.visibility = View.VISIBLE
            previewChannelName.text = channel.name
            previewTime.text = getCurrentTimeString()
            previewProgramInfo.text = if (channel.number != null) {
                "Channel #${channel.number} - Live TV"
            } else {
                "Live TV"
            }
        }
    }
    
    private fun getCurrentTimeString(): String {
        val calendar = java.util.Calendar.getInstance()
        val hour = calendar.get(java.util.Calendar.HOUR_OF_DAY)
        val minute = calendar.get(java.util.Calendar.MINUTE)
        return String.format("%02d:%02d", hour, minute)
    }
    
    override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
        android.util.Log.d("MainActivity", "Key pressed: $keyCode")
        
        // Handle BACK button - progressive navigation like LEFT key
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            // In video fullscreen - exit to preview/content view
            if (isFullscreen) {
                if (selectedTab == "TV") {
                    // Exit to preview + channel view (keep sidebars hidden)
                    toggleFullscreen()
                    // Ensure sidebars stay hidden
                    sidebarContainer.visibility = View.GONE
                    categorySidebar.visibility = View.GONE
                    // Focus on preview
                    playerPreviewContainer.requestFocus()
                } else {
                    // Exit movie fullscreen view
                    exitMovieFullscreen()
                }
                return true
            }
            
            // In content view (TV/Movies/Shows) with both sidebars hidden - show categories
            if (categorySidebar.visibility == View.GONE && 
                sidebarContainer.visibility == View.GONE) {
                // Show categories sidebar
                categorySidebar.visibility = View.VISIBLE
                
                // Clear channel selection for Live TV
                if (selectedTab == "TV") {
                    channelRowAdapter.clearSelection()
                }
                
                // Recalculate grid for Movies/Shows
                if (selectedTab == "MOVIES" || selectedTab == "SHOWS") {
                    setupContentAdapter()
                }
                
                // Move focus to the category that has the playing channel
                categoriesRecycler.requestFocus()
                categoriesRecycler.post {
                    // Focus on the category that has the playing channel
                    val categoryIndexToFocus = if (currentPlayingCategoryId != null) {
                        // Find the category with the playing channel
                        categories.indexOfFirst { it.id == currentPlayingCategoryId }
                    } else {
                        selectedCategoryIndex
                    }
                    val position = if (categoryIndexToFocus >= 0) categoryIndexToFocus else 0
                    val layoutManager = categoriesRecycler.layoutManager as? androidx.recyclerview.widget.LinearLayoutManager
                    layoutManager?.let {
                        val viewAtPosition = it.findViewByPosition(position)
                        viewAtPosition?.requestFocus()
                    }
                }
                return true
            }
            
            // In categories with main sidebar hidden - show main sidebar
            if (categorySidebar.visibility == View.VISIBLE && 
                sidebarContainer.visibility == View.GONE) {
                // Show main sidebar
                sidebarContainer.visibility = View.VISIBLE
                
                // Focus on current tab
                when (selectedTab) {
                    "TV" -> tvTab.requestFocus()
                    "MOVIES" -> moviesTab.requestFocus()
                    "SHOWS" -> showsTab.requestFocus()
                }
                return true
            }
            
            // Otherwise, let system handle BACK (exit app)
        }
        
        // Handle UP/DOWN in fullscreen mode for channel navigation
        if (isFullscreen && selectedTab == "TV") {
            when (keyCode) {
                KeyEvent.KEYCODE_DPAD_UP -> {
                    playPreviousChannel()
                    return true
                }
                KeyEvent.KEYCODE_DPAD_DOWN -> {
                    playNextChannel()
                    return true
                }
            }
        }
        
        when (keyCode) {
            KeyEvent.KEYCODE_DPAD_RIGHT -> {
                // Navigate from icon sidebar to categories (also activates the tab)
                if (tvTab.hasFocus()) {
                    switchTab("TV")
                    // Focus will be set by loadCategories
                    return true
                } else if (moviesTab.hasFocus()) {
                    switchTab("MOVIES")
                    categoriesRecycler.requestFocus()
                    categoriesRecycler.post {
                        categoriesRecycler.getChildAt(0)?.requestFocus()
                    }
                    return true
                } else if (showsTab.hasFocus()) {
                    switchTab("SHOWS")
                    categoriesRecycler.requestFocus()
                    categoriesRecycler.post {
                        categoriesRecycler.getChildAt(0)?.requestFocus()
                    }
                    return true
                }
                // Navigate from categories to content
                if (categoriesRecycler.hasFocus()) {
                    // Get the currently focused category
                    val focusedChild = categoriesRecycler.focusedChild
                    if (focusedChild != null) {
                        val position = categoriesRecycler.getChildAdapterPosition(focusedChild)
                        if (position != RecyclerView.NO_POSITION && position < categories.size) {
                            // Select this category (will load content and hide sidebars)
                            onCategorySelected(categories[position])
                            return true
                        }
                    }
                    return true
                }
            }
            KeyEvent.KEYCODE_DPAD_LEFT -> {
                // Progressive LEFT navigation: Content  Categories  Main Sidebar
                
                // Level 3: From content back to categories
                val focusedChild = currentFocus
                var parent = focusedChild?.parent
                var isInContentRecycler = false
                while (parent != null) {
                    if (parent == contentRecycler) {
                        isInContentRecycler = true
                        break
                    }
                    parent = parent.parent
                }
                
                if (isInContentRecycler && hasCategorySelected) {
                    // For Movies/Shows: Check if we're in first column of the grid
                    if (selectedTab == "MOVIES" || selectedTab == "SHOWS") {
                        val gridLayoutManager = contentRecycler.layoutManager as? GridLayoutManager
                        val focusedPosition = contentRecycler.getChildAdapterPosition(focusedChild ?: return super.onKeyDown(keyCode, event))
                        
                        if (gridLayoutManager != null && focusedPosition != RecyclerView.NO_POSITION) {
                            val spanCount = gridLayoutManager.spanCount
                            val isFirstColumn = focusedPosition % spanCount == 0
                            
                            android.util.Log.d("MainActivity", "LEFT in grid: position=$focusedPosition, spanCount=$spanCount, isFirstColumn=$isFirstColumn")
                            
                            if (!isFirstColumn) {
                                // Not in first column, don't exit - let grid handle it
                                return super.onKeyDown(keyCode, event)
                            }
                        }
                        
                        // In first column - clear selection and exit to categories
                        channelAdapter.clearSelection()
                    }
                    
                    // For TV: Always allow LEFT to exit back to categories (even from first channel)
                    // Show categories sidebar
                    categorySidebar.visibility = View.VISIBLE
                    
                    // Clear channel selection for Live TV
                    if (selectedTab == "TV") {
                        channelRowAdapter.clearSelection()
                    }
                    
                    // Recalculate grid layout for Movies/Shows
                    if (selectedTab == "MOVIES" || selectedTab == "SHOWS") {
                        setupContentAdapter()
                    }
                    
                    // Move focus to the category that has the playing channel
                    categoriesRecycler.requestFocus()
                    categoriesRecycler.post {
                        val layoutManager = categoriesRecycler.layoutManager as? androidx.recyclerview.widget.LinearLayoutManager
                        layoutManager?.let {
                            // Focus on the category that has the playing channel
                            val categoryIndexToFocus = if (currentPlayingCategoryId != null) {
                                // Find the category with the playing channel
                                categories.indexOfFirst { it.id == currentPlayingCategoryId }
                            } else {
                                selectedCategoryIndex
                            }
                            val position = if (categoryIndexToFocus >= 0) categoryIndexToFocus else 0
                            val viewAtPosition = it.findViewByPosition(position)
                            viewAtPosition?.requestFocus()
                        }
                    }
                    return true
                }
                
                // Level 2: From categories back to main sidebar
                if (categoriesRecycler.hasFocus()) {
                    // Show main sidebar
                    sidebarContainer.visibility = View.VISIBLE
                    
                    // Focus on current tab
                    when (selectedTab) {
                        "TV" -> tvTab.requestFocus()
                        "MOVIES" -> moviesTab.requestFocus()
                        "SHOWS" -> showsTab.requestFocus()
                    }
                    return true
                }
            }
            KeyEvent.KEYCODE_DPAD_UP -> {
                // Navigate UP in main sidebar
                if (tvTab.hasFocus()) {
                    // Already at top, do nothing
                    return true
                } else if (moviesTab.hasFocus()) {
                    tvTab.requestFocus()
                    return true
                } else if (showsTab.hasFocus()) {
                    moviesTab.requestFocus()
                    return true
                }
                
                // For Live TV: UP from first channel goes to preview
                if (selectedTab == "TV" && contentRecycler.hasFocus()) {
                    val focusedChild = currentFocus
                    var parent = focusedChild?.parent
                    var isInContentRecycler = false
                    while (parent != null) {
                        if (parent == contentRecycler) {
                            isInContentRecycler = true
                            break
                        }
                        parent = parent.parent
                    }
                    
                    if (isInContentRecycler) {
                        val focusedPosition = contentRecycler.getChildAdapterPosition(focusedChild ?: return super.onKeyDown(keyCode, event))
                        // Only allow UP from first channel (position 0)
                        if (focusedPosition == 0) {
                            // Focus on preview container
                            playerPreviewContainer.requestFocus()
                            return true
                        }
                    }
                }
                
                // Allow normal UP navigation within content
                return super.onKeyDown(keyCode, event)
            }
            KeyEvent.KEYCODE_DPAD_DOWN -> {
                // Navigate DOWN in main sidebar
                if (tvTab.hasFocus()) {
                    moviesTab.requestFocus()
                    return true
                } else if (moviesTab.hasFocus()) {
                    showsTab.requestFocus()
                    return true
                } else if (showsTab.hasFocus()) {
                    // Already at bottom, do nothing
                    return true
                }
                
                // For Live TV: DOWN from preview goes to first channel
                if (selectedTab == "TV" && playerPreviewContainer.hasFocus()) {
                    contentRecycler.requestFocus()
                    contentRecycler.post {
                        contentRecycler.getChildAt(0)?.requestFocus()
                    }
                    return true
                }
                
                // Allow normal DOWN navigation within content
                return super.onKeyDown(keyCode, event)
            }
            KeyEvent.KEYCODE_DPAD_CENTER, KeyEvent.KEYCODE_ENTER -> {
                // Handle CENTER on preview to toggle fullscreen
                if (playerPreviewContainer.hasFocus() && selectedTab == "TV" && currentPlayingChannel != null) {
                    toggleFullscreen()
                    return true
                }
                
                // Handle CENTER on main sidebar tabs to activate and move to content
                if (tvTab.hasFocus()) {
                    switchTab("TV")
                    // Focus will be set by loadCategories to first channel
                    return true
                }
                if (moviesTab.hasFocus()) {
                    switchTab("MOVIES")
                    // Focus on categories
                    categoriesRecycler.requestFocus()
                    categoriesRecycler.post {
                        categoriesRecycler.getChildAt(0)?.requestFocus()
                    }
                    return true
                }
                if (showsTab.hasFocus()) {
                    switchTab("SHOWS")
                    // Focus on categories
                    categoriesRecycler.requestFocus()
                    categoriesRecycler.post {
                        categoriesRecycler.getChildAt(0)?.requestFocus()
                    }
                    return true
                }
                
                // Handle CENTER on categories to activate and move to content
                if (categoriesRecycler.hasFocus()) {
                    // RIGHT key handler will take care of this
                    return super.onKeyDown(keyCode, event)
                }
                
                android.util.Log.d("MainActivity", "CENTER pressed on: $hoverTab")
                return super.onKeyDown(keyCode, event)
            }
        }
        
        return super.onKeyDown(keyCode, event)
    }
    
    private fun playChannel(channel: Channel) {
        currentPlayingChannel = channel
        
        val rawCmd = channel.cmd ?: ""
        android.util.Log.d("MainActivity", "Playing channel: ${channel.name}, CMD: $rawCmd")
        android.util.Log.d("MainActivity", "Movie/Channel ID: ${channel.id}")
        
        if (rawCmd.isEmpty()) {
            android.util.Log.e("MainActivity", "Empty CMD!")
            return
        }
        
        // Determine content type based on cmd format
        // Live TV: "ffrt http://..." or "ffmpeg http://..."
        // Movies/VOD: "/media/123456.mpg"
        val contentType = if (rawCmd.startsWith("ffrt") || rawCmd.startsWith("ffmpeg")) {
            "itv"
        } else {
            "vod"
        }
        
        val isLive = contentType == "itv"
        val targetPlayer = if (isLive) livePlayer else vodPlayer
        
        android.util.Log.d("MainActivity", "Content type: $contentType")
        
        // Get actual stream URL from backend API
        lifecycleScope.launch {
            try {
                // For VOD content, we need to get movie info first
                var finalCmd = rawCmd
                if (contentType == "vod") {
                    android.util.Log.d("MainActivity", "VOD detected - getting movie info for ID: ${channel.id}")
                    try {
                        val movieInfoResponse = ApiClient.apiService.getMovieInfo(
                            mapOf(
                                "mac" to ApiClient.macAddress,
                                "url" to ApiClient.portalUrl,
                                "movieId" to channel.id
                            )
                        )
                        val fileInfo = movieInfoResponse.fileInfo
                        if (fileInfo != null && fileInfo.id != null) {
                            finalCmd = "/media/file_${fileInfo.id}.mpg"
                            android.util.Log.d("MainActivity", "Got movie file info - new CMD: $finalCmd")
                        } else {
                            android.util.Log.w("MainActivity", "No file info found, using original CMD")
                        }
                    } catch (e: Exception) {
                        android.util.Log.e("MainActivity", "Error getting movie info: ${e.message}")
                        // Continue with original CMD
                    }
                }
                
                android.util.Log.d("MainActivity", "Requesting stream URL from API with CMD: $finalCmd")
                val response = ApiClient.apiService.getStreamUrl(
                    mapOf(
                        "mac" to ApiClient.macAddress,
                        "url" to ApiClient.portalUrl,
                        "cmd" to finalCmd,
                        "type" to contentType
                    )
                )
                
                val streamUrl = response.url
                android.util.Log.d("MainActivity", "Got stream URL: $streamUrl")
                
                if (streamUrl.isEmpty()) {
                    android.util.Log.e("MainActivity", "Received empty stream URL")
                    return@launch
                }
                
                // Prepare media item first
                val mediaItem = MediaItem.Builder()
                    .setUri(streamUrl)
                    .build()
                
                // Stop BOTH players to prevent overlapping audio
                android.util.Log.d("MainActivity", "Stopping all players...")
                livePlayer?.apply {
                    stop()
                    clearMediaItems()
                }
                vodPlayer?.apply {
                    stop()
                    clearMediaItems()
                }
                    
                targetPlayer?.apply {
                    android.util.Log.d("MainActivity", "Setting new media item...")
                    setMediaItem(mediaItem)
                    android.util.Log.d("MainActivity", "Preparing player...")
                    prepare()
                }
                
                // Switch PlayerView to the appropriate player AFTER preparing media
                // This ensures the surface is properly attached when playback starts
                playerView.player = targetPlayer
                android.util.Log.d("MainActivity", "Switched PlayerView to ${if (isLive) "Live" else "VOD"} player")
                
                // Start playback
                targetPlayer?.apply {
                    android.util.Log.d("MainActivity", "Starting playback...")
                    playWhenReady = true
                }
                
                // Update player controls based on content type
                updatePlayerControlsForContentType()
                
                android.util.Log.d("MainActivity", "Player started successfully")
            } catch (e: Exception) {
                android.util.Log.e("MainActivity", "Error getting stream URL: ${e.message}", e)
                e.printStackTrace()
            }
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        livePlayer?.release()
        livePlayer = null
        vodPlayer?.release()
        vodPlayer = null
    }
}
